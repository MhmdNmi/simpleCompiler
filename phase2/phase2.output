

Terminals which are not used:

   LEFTBRACE
   RIGHTBRACE


Conflict in state 118 between rule 55 and token OR resolved as reduce.
Conflict in state 118 between rule 55 and token AND resolved as reduce.
Conflict in state 119 between rule 54 and token OR resolved as reduce.
Conflict in state 119 between rule 54 and token AND resolved as reduce.

Grammar
rule 1    S ->		/* empty */
rule 2    S -> M
rule 3    M -> FUNC M
rule 4    M -> INT MAIN LEFTPAREN RIGHTPAREN LEFTB STMTS RIGHTB
rule 5    FUNC -> TYPE IDENTIFIER LEFTPAREN RIGHTPAREN LEFTB STMTS RIGHTB
rule 6    FUNC -> TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB
rule 7    FUNC -> TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB
rule 8    FUNC -> TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB
rule 9    FUNCCALL -> IDENTIFIER LEFTPAREN EXPR RIGHTPAREN
rule 10   FUNCCALL -> IDENTIFIER LEFTPAREN EXPR COMMA EXPR RIGHTPAREN
rule 11   FUNCCALL -> IDENTIFIER LEFTPAREN EXPR COMMA EXPR COMMA EXPR RIGHTPAREN
rule 12   TYPE -> VOID
rule 13   TYPE -> CHAR
rule 14   TYPE -> INT
rule 15   STMTS -> STMT STMTS
rule 16   STMTS -> STMT
rule 17   VARDEF1 -> INT IDENTIFIER DOT
rule 18   VARDEF1 -> CHAR IDENTIFIER DOT
rule 19   VARDEF2 -> INT IDENTIFIER ASSIGN INT_CONST DOT
rule 20   VARDEF2 -> CHAR IDENTIFIER ASSIGN CHAR_CONST DOT
rule 21   STMT -> IFSTMT
rule 22   STMT -> WHILESTMT
rule 23   STMT -> FORSTMT
rule 24   STMT -> VARDEF1
rule 25   STMT -> VARDEF2
rule 26   STMT -> STEP DOT
rule 27   STMT -> RETURN EXPR DOT
rule 28   STMT -> BREAK DOT
rule 29   STMT -> CONTINUE DOT
rule 30   STEP -> IDENTIFIER ASSIGN EXPR
rule 31   EXPR -> VALUE PLUS VALUE
rule 32   EXPR -> VALUE MINUS VALUE
rule 33   EXPR -> VALUE MULTIPLY VALUE
rule 34   EXPR -> VALUE DIVIDE VALUE
rule 35   EXPR -> VALUE ANDBIT VALUE
rule 36   EXPR -> VALUE ORBIT VALUE
rule 37   EXPR -> VALUE XORBIT VALUE
rule 38   EXPR -> VALUE
rule 39   COMPOP -> LEFTB
rule 40   COMPOP -> RIGHTB
rule 41   COMPOP -> ISLESSEQ
rule 42   COMPOP -> ISMOREQ
rule 43   COMPOP -> ISEQL
rule 44   COMPOP -> ISNEQL
rule 45   VALUE -> INT_CONST
rule 46   VALUE -> CHAR_CONST
rule 47   VALUE -> IDENTIFIER
rule 48   VALUE -> FUNCCALL
rule 49   VALUE -> LEFTPAREN VALUE RIGHTPAREN
rule 50   COND -> EXPR COMPOP EXPR
rule 51   COND -> CONDS
rule 52   COND -> NOT LEFTPAREN COND RIGHTPAREN
rule 53   COND -> EXPR
rule 54   CONDS -> COND AND COND
rule 55   CONDS -> COND OR COND
rule 56   IFSTMT -> IF LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB
rule 57   IFSTMT -> IF LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB ELSE LEFTB STMTS RIGHTB
rule 58   IFSTMT -> IF LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB ELIFSTMTS ELSE LEFTB STMTS RIGHTB
rule 59   ELIFSTMTS -> ELIFSTMT ELIFSTMTS
rule 60   ELIFSTMTS -> ELIFSTMT
rule 61   ELIFSTMT -> ELSEIF LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB
rule 62   WHILESTMT -> WHILE LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB
rule 63   FORSTMT -> FOR LEFTPAREN VARDEF2 COND DOT STEP RIGHTPAREN LEFTB STMTS RIGHTB

Terminals, with rules where they appear

$ (-1)
error (256)
MAIN (258) 4
INT (259) 4 14 17 19
CHAR (260) 13 18 20
IF (261) 56 57 58
ELSE (262) 57 58
ELSEIF (263) 61
WHILE (264) 62
CONTINUE (265) 29
BREAK (266) 28
FOR (267) 63
RETURN (268) 27
VOID (269) 12
IDENTIFIER (270) 5 6 7 8 9 10 11 17 18 19 20 30 47
INT_CONST (271) 19 45
CHAR_CONST (272) 20 46
DOT (273) 17 18 19 20 26 27 28 29 63
COMMA (274) 7 8 10 11
ISLESSEQ (275) 41
ISMOREQ (276) 42
ISEQL (277) 43
ISNEQL (278) 44
ASSIGN (279) 19 20 30
LEFTB (280) 4 5 6 7 8 39 56 57 58 61 62 63
RIGHTB (281) 4 5 6 7 8 40 56 57 58 61 62 63
OR (282) 55
ORBIT (283) 36
AND (284) 54
ANDBIT (285) 35
XORBIT (286) 37
NOT (287) 52
PLUS (288) 31
MINUS (289) 32
MULTIPLY (290) 33
DIVIDE (291) 34
LEFTPAREN (292) 4 5 6 7 8 9 10 11 49 52 56 57 58 61 62 63
RIGHTPAREN (293) 4 5 6 7 8 9 10 11 49 52 56 57 58 61 62 63
LEFTBRACE (294)
RIGHTBRACE (295)

Nonterminals, with rules where they appear

S (41)
    on left: 1 2
M (42)
    on left: 3 4, on right: 2 3
FUNC (43)
    on left: 5 6 7 8, on right: 3
FUNCCALL (44)
    on left: 9 10 11, on right: 48
TYPE (45)
    on left: 12 13 14, on right: 5 6 7 8
STMTS (46)
    on left: 15 16, on right: 4 5 6 7 8 15 56 57 58 61 62 63
VARDEF1 (47)
    on left: 17 18, on right: 24
VARDEF2 (48)
    on left: 19 20, on right: 25 63
STMT (49)
    on left: 21 22 23 24 25 26 27 28 29, on right: 15 16
STEP (50)
    on left: 30, on right: 26 63
EXPR (51)
    on left: 31 32 33 34 35 36 37 38, on right: 9 10 11 27 30 50 53
COMPOP (52)
    on left: 39 40 41 42 43 44, on right: 50
VALUE (53)
    on left: 45 46 47 48 49, on right: 31 32 33 34 35 36 37 38 49
COND (54)
    on left: 50 51 52 53, on right: 52 54 55 56 57 58 61 62 63
CONDS (55)
    on left: 54 55, on right: 51
IFSTMT (56)
    on left: 56 57 58, on right: 21
ELIFSTMTS (57)
    on left: 59 60, on right: 58 59
ELIFSTMT (58)
    on left: 61, on right: 59 60
WHILESTMT (59)
    on left: 62, on right: 22
FORSTMT (60)
    on left: 63, on right: 23


state 0

    INT 	shift, and go to state 1
    CHAR	shift, and go to state 2
    VOID	shift, and go to state 3

    $default	reduce using rule 1 (S)

    S   	go to state 167
    M   	go to state 4
    FUNC	go to state 5
    TYPE	go to state 6



state 1

    M  ->  INT . MAIN LEFTPAREN RIGHTPAREN LEFTB STMTS RIGHTB   (rule 4)
    TYPE  ->  INT .   (rule 14)

    MAIN	shift, and go to state 7

    $default	reduce using rule 14 (TYPE)



state 2

    TYPE  ->  CHAR .   (rule 13)

    $default	reduce using rule 13 (TYPE)



state 3

    TYPE  ->  VOID .   (rule 12)

    $default	reduce using rule 12 (TYPE)



state 4

    S  ->  M .   (rule 2)

    $default	reduce using rule 2 (S)



state 5

    M  ->  FUNC . M   (rule 3)

    INT 	shift, and go to state 1
    CHAR	shift, and go to state 2
    VOID	shift, and go to state 3

    M   	go to state 8
    FUNC	go to state 5
    TYPE	go to state 6



state 6

    FUNC  ->  TYPE . IDENTIFIER LEFTPAREN RIGHTPAREN LEFTB STMTS RIGHTB   (rule 5)
    FUNC  ->  TYPE . IDENTIFIER LEFTPAREN TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 6)
    FUNC  ->  TYPE . IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 7)
    FUNC  ->  TYPE . IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 8)

    IDENTIFIER	shift, and go to state 9



state 7

    M  ->  INT MAIN . LEFTPAREN RIGHTPAREN LEFTB STMTS RIGHTB   (rule 4)

    LEFTPAREN	shift, and go to state 10



state 8

    M  ->  FUNC M .   (rule 3)

    $default	reduce using rule 3 (M)



state 9

    FUNC  ->  TYPE IDENTIFIER . LEFTPAREN RIGHTPAREN LEFTB STMTS RIGHTB   (rule 5)
    FUNC  ->  TYPE IDENTIFIER . LEFTPAREN TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 6)
    FUNC  ->  TYPE IDENTIFIER . LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 7)
    FUNC  ->  TYPE IDENTIFIER . LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 8)

    LEFTPAREN	shift, and go to state 11



state 10

    M  ->  INT MAIN LEFTPAREN . RIGHTPAREN LEFTB STMTS RIGHTB   (rule 4)

    RIGHTPAREN	shift, and go to state 12



state 11

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN . RIGHTPAREN LEFTB STMTS RIGHTB   (rule 5)
    FUNC  ->  TYPE IDENTIFIER LEFTPAREN . TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 6)
    FUNC  ->  TYPE IDENTIFIER LEFTPAREN . TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 7)
    FUNC  ->  TYPE IDENTIFIER LEFTPAREN . TYPE IDENTIFIER COMMA TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 8)

    INT 	shift, and go to state 13
    CHAR	shift, and go to state 2
    VOID	shift, and go to state 3
    RIGHTPAREN	shift, and go to state 14

    TYPE	go to state 15



state 12

    M  ->  INT MAIN LEFTPAREN RIGHTPAREN . LEFTB STMTS RIGHTB   (rule 4)

    LEFTB	shift, and go to state 16



state 13

    TYPE  ->  INT .   (rule 14)

    $default	reduce using rule 14 (TYPE)



state 14

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN RIGHTPAREN . LEFTB STMTS RIGHTB   (rule 5)

    LEFTB	shift, and go to state 17



state 15

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE . IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 6)
    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE . IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 7)
    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE . IDENTIFIER COMMA TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 8)

    IDENTIFIER	shift, and go to state 18



state 16

    M  ->  INT MAIN LEFTPAREN RIGHTPAREN LEFTB . STMTS RIGHTB   (rule 4)

    INT 	shift, and go to state 19
    CHAR	shift, and go to state 20
    IF  	shift, and go to state 21
    WHILE	shift, and go to state 22
    CONTINUE	shift, and go to state 23
    BREAK	shift, and go to state 24
    FOR 	shift, and go to state 25
    RETURN	shift, and go to state 26
    IDENTIFIER	shift, and go to state 27

    STMTS	go to state 28
    VARDEF1	go to state 29
    VARDEF2	go to state 30
    STMT	go to state 31
    STEP	go to state 32
    IFSTMT	go to state 33
    WHILESTMT	go to state 34
    FORSTMT	go to state 35



state 17

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN RIGHTPAREN LEFTB . STMTS RIGHTB   (rule 5)

    INT 	shift, and go to state 19
    CHAR	shift, and go to state 20
    IF  	shift, and go to state 21
    WHILE	shift, and go to state 22
    CONTINUE	shift, and go to state 23
    BREAK	shift, and go to state 24
    FOR 	shift, and go to state 25
    RETURN	shift, and go to state 26
    IDENTIFIER	shift, and go to state 27

    STMTS	go to state 36
    VARDEF1	go to state 29
    VARDEF2	go to state 30
    STMT	go to state 31
    STEP	go to state 32
    IFSTMT	go to state 33
    WHILESTMT	go to state 34
    FORSTMT	go to state 35



state 18

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER . RIGHTPAREN LEFTB STMTS RIGHTB   (rule 6)
    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER . COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 7)
    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER . COMMA TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 8)

    COMMA	shift, and go to state 37
    RIGHTPAREN	shift, and go to state 38



state 19

    VARDEF1  ->  INT . IDENTIFIER DOT   (rule 17)
    VARDEF2  ->  INT . IDENTIFIER ASSIGN INT_CONST DOT   (rule 19)

    IDENTIFIER	shift, and go to state 39



state 20

    VARDEF1  ->  CHAR . IDENTIFIER DOT   (rule 18)
    VARDEF2  ->  CHAR . IDENTIFIER ASSIGN CHAR_CONST DOT   (rule 20)

    IDENTIFIER	shift, and go to state 40



state 21

    IFSTMT  ->  IF . LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB   (rule 56)
    IFSTMT  ->  IF . LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB ELSE LEFTB STMTS RIGHTB   (rule 57)
    IFSTMT  ->  IF . LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB ELIFSTMTS ELSE LEFTB STMTS RIGHTB   (rule 58)

    LEFTPAREN	shift, and go to state 41



state 22

    WHILESTMT  ->  WHILE . LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB   (rule 62)

    LEFTPAREN	shift, and go to state 42



state 23

    STMT  ->  CONTINUE . DOT   (rule 29)

    DOT 	shift, and go to state 43



state 24

    STMT  ->  BREAK . DOT   (rule 28)

    DOT 	shift, and go to state 44



state 25

    FORSTMT  ->  FOR . LEFTPAREN VARDEF2 COND DOT STEP RIGHTPAREN LEFTB STMTS RIGHTB   (rule 63)

    LEFTPAREN	shift, and go to state 45



state 26

    STMT  ->  RETURN . EXPR DOT   (rule 27)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    EXPR	go to state 51
    VALUE	go to state 52



state 27

    STEP  ->  IDENTIFIER . ASSIGN EXPR   (rule 30)

    ASSIGN	shift, and go to state 53



state 28

    M  ->  INT MAIN LEFTPAREN RIGHTPAREN LEFTB STMTS . RIGHTB   (rule 4)

    RIGHTB	shift, and go to state 54



state 29

    STMT  ->  VARDEF1 .   (rule 24)

    $default	reduce using rule 24 (STMT)



state 30

    STMT  ->  VARDEF2 .   (rule 25)

    $default	reduce using rule 25 (STMT)



state 31

    STMTS  ->  STMT . STMTS   (rule 15)
    STMTS  ->  STMT .   (rule 16)

    INT 	shift, and go to state 19
    CHAR	shift, and go to state 20
    IF  	shift, and go to state 21
    WHILE	shift, and go to state 22
    CONTINUE	shift, and go to state 23
    BREAK	shift, and go to state 24
    FOR 	shift, and go to state 25
    RETURN	shift, and go to state 26
    IDENTIFIER	shift, and go to state 27

    $default	reduce using rule 16 (STMTS)

    STMTS	go to state 55
    VARDEF1	go to state 29
    VARDEF2	go to state 30
    STMT	go to state 31
    STEP	go to state 32
    IFSTMT	go to state 33
    WHILESTMT	go to state 34
    FORSTMT	go to state 35



state 32

    STMT  ->  STEP . DOT   (rule 26)

    DOT 	shift, and go to state 56



state 33

    STMT  ->  IFSTMT .   (rule 21)

    $default	reduce using rule 21 (STMT)



state 34

    STMT  ->  WHILESTMT .   (rule 22)

    $default	reduce using rule 22 (STMT)



state 35

    STMT  ->  FORSTMT .   (rule 23)

    $default	reduce using rule 23 (STMT)



state 36

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN RIGHTPAREN LEFTB STMTS . RIGHTB   (rule 5)

    RIGHTB	shift, and go to state 57



state 37

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA . TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 7)
    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA . TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 8)

    INT 	shift, and go to state 13
    CHAR	shift, and go to state 2
    VOID	shift, and go to state 3

    TYPE	go to state 58



state 38

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER RIGHTPAREN . LEFTB STMTS RIGHTB   (rule 6)

    LEFTB	shift, and go to state 59



state 39

    VARDEF1  ->  INT IDENTIFIER . DOT   (rule 17)
    VARDEF2  ->  INT IDENTIFIER . ASSIGN INT_CONST DOT   (rule 19)

    DOT 	shift, and go to state 60
    ASSIGN	shift, and go to state 61



state 40

    VARDEF1  ->  CHAR IDENTIFIER . DOT   (rule 18)
    VARDEF2  ->  CHAR IDENTIFIER . ASSIGN CHAR_CONST DOT   (rule 20)

    DOT 	shift, and go to state 62
    ASSIGN	shift, and go to state 63



state 41

    IFSTMT  ->  IF LEFTPAREN . COND RIGHTPAREN LEFTB STMTS RIGHTB   (rule 56)
    IFSTMT  ->  IF LEFTPAREN . COND RIGHTPAREN LEFTB STMTS RIGHTB ELSE LEFTB STMTS RIGHTB   (rule 57)
    IFSTMT  ->  IF LEFTPAREN . COND RIGHTPAREN LEFTB STMTS RIGHTB ELIFSTMTS ELSE LEFTB STMTS RIGHTB   (rule 58)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    NOT 	shift, and go to state 64
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    EXPR	go to state 65
    VALUE	go to state 52
    COND	go to state 66
    CONDS	go to state 67



state 42

    WHILESTMT  ->  WHILE LEFTPAREN . COND RIGHTPAREN LEFTB STMTS RIGHTB   (rule 62)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    NOT 	shift, and go to state 64
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    EXPR	go to state 65
    VALUE	go to state 52
    COND	go to state 68
    CONDS	go to state 67



state 43

    STMT  ->  CONTINUE DOT .   (rule 29)

    $default	reduce using rule 29 (STMT)



state 44

    STMT  ->  BREAK DOT .   (rule 28)

    $default	reduce using rule 28 (STMT)



state 45

    FORSTMT  ->  FOR LEFTPAREN . VARDEF2 COND DOT STEP RIGHTPAREN LEFTB STMTS RIGHTB   (rule 63)

    INT 	shift, and go to state 69
    CHAR	shift, and go to state 70

    VARDEF2	go to state 71



state 46

    FUNCCALL  ->  IDENTIFIER . LEFTPAREN EXPR RIGHTPAREN   (rule 9)
    FUNCCALL  ->  IDENTIFIER . LEFTPAREN EXPR COMMA EXPR RIGHTPAREN   (rule 10)
    FUNCCALL  ->  IDENTIFIER . LEFTPAREN EXPR COMMA EXPR COMMA EXPR RIGHTPAREN   (rule 11)
    VALUE  ->  IDENTIFIER .   (rule 47)

    LEFTPAREN	shift, and go to state 72

    $default	reduce using rule 47 (VALUE)



state 47

    VALUE  ->  INT_CONST .   (rule 45)

    $default	reduce using rule 45 (VALUE)



state 48

    VALUE  ->  CHAR_CONST .   (rule 46)

    $default	reduce using rule 46 (VALUE)



state 49

    VALUE  ->  LEFTPAREN . VALUE RIGHTPAREN   (rule 49)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    VALUE	go to state 73



state 50

    VALUE  ->  FUNCCALL .   (rule 48)

    $default	reduce using rule 48 (VALUE)



state 51

    STMT  ->  RETURN EXPR . DOT   (rule 27)

    DOT 	shift, and go to state 74



state 52

    EXPR  ->  VALUE . PLUS VALUE   (rule 31)
    EXPR  ->  VALUE . MINUS VALUE   (rule 32)
    EXPR  ->  VALUE . MULTIPLY VALUE   (rule 33)
    EXPR  ->  VALUE . DIVIDE VALUE   (rule 34)
    EXPR  ->  VALUE . ANDBIT VALUE   (rule 35)
    EXPR  ->  VALUE . ORBIT VALUE   (rule 36)
    EXPR  ->  VALUE . XORBIT VALUE   (rule 37)
    EXPR  ->  VALUE .   (rule 38)

    ORBIT	shift, and go to state 75
    ANDBIT	shift, and go to state 76
    XORBIT	shift, and go to state 77
    PLUS	shift, and go to state 78
    MINUS	shift, and go to state 79
    MULTIPLY	shift, and go to state 80
    DIVIDE	shift, and go to state 81

    $default	reduce using rule 38 (EXPR)



state 53

    STEP  ->  IDENTIFIER ASSIGN . EXPR   (rule 30)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    EXPR	go to state 82
    VALUE	go to state 52



state 54

    M  ->  INT MAIN LEFTPAREN RIGHTPAREN LEFTB STMTS RIGHTB .   (rule 4)

    $default	reduce using rule 4 (M)



state 55

    STMTS  ->  STMT STMTS .   (rule 15)

    $default	reduce using rule 15 (STMTS)



state 56

    STMT  ->  STEP DOT .   (rule 26)

    $default	reduce using rule 26 (STMT)



state 57

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN RIGHTPAREN LEFTB STMTS RIGHTB .   (rule 5)

    $default	reduce using rule 5 (FUNC)



state 58

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE . IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 7)
    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE . IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 8)

    IDENTIFIER	shift, and go to state 83



state 59

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER RIGHTPAREN LEFTB . STMTS RIGHTB   (rule 6)

    INT 	shift, and go to state 19
    CHAR	shift, and go to state 20
    IF  	shift, and go to state 21
    WHILE	shift, and go to state 22
    CONTINUE	shift, and go to state 23
    BREAK	shift, and go to state 24
    FOR 	shift, and go to state 25
    RETURN	shift, and go to state 26
    IDENTIFIER	shift, and go to state 27

    STMTS	go to state 84
    VARDEF1	go to state 29
    VARDEF2	go to state 30
    STMT	go to state 31
    STEP	go to state 32
    IFSTMT	go to state 33
    WHILESTMT	go to state 34
    FORSTMT	go to state 35



state 60

    VARDEF1  ->  INT IDENTIFIER DOT .   (rule 17)

    $default	reduce using rule 17 (VARDEF1)



state 61

    VARDEF2  ->  INT IDENTIFIER ASSIGN . INT_CONST DOT   (rule 19)

    INT_CONST	shift, and go to state 85



state 62

    VARDEF1  ->  CHAR IDENTIFIER DOT .   (rule 18)

    $default	reduce using rule 18 (VARDEF1)



state 63

    VARDEF2  ->  CHAR IDENTIFIER ASSIGN . CHAR_CONST DOT   (rule 20)

    CHAR_CONST	shift, and go to state 86



state 64

    COND  ->  NOT . LEFTPAREN COND RIGHTPAREN   (rule 52)

    LEFTPAREN	shift, and go to state 87



state 65

    COND  ->  EXPR . COMPOP EXPR   (rule 50)
    COND  ->  EXPR .   (rule 53)

    ISLESSEQ	shift, and go to state 88
    ISMOREQ	shift, and go to state 89
    ISEQL	shift, and go to state 90
    ISNEQL	shift, and go to state 91
    LEFTB	shift, and go to state 92
    RIGHTB	shift, and go to state 93

    $default	reduce using rule 53 (COND)

    COMPOP	go to state 94



state 66

    CONDS  ->  COND . AND COND   (rule 54)
    CONDS  ->  COND . OR COND   (rule 55)
    IFSTMT  ->  IF LEFTPAREN COND . RIGHTPAREN LEFTB STMTS RIGHTB   (rule 56)
    IFSTMT  ->  IF LEFTPAREN COND . RIGHTPAREN LEFTB STMTS RIGHTB ELSE LEFTB STMTS RIGHTB   (rule 57)
    IFSTMT  ->  IF LEFTPAREN COND . RIGHTPAREN LEFTB STMTS RIGHTB ELIFSTMTS ELSE LEFTB STMTS RIGHTB   (rule 58)

    OR  	shift, and go to state 95
    AND 	shift, and go to state 96
    RIGHTPAREN	shift, and go to state 97



state 67

    COND  ->  CONDS .   (rule 51)

    $default	reduce using rule 51 (COND)



state 68

    CONDS  ->  COND . AND COND   (rule 54)
    CONDS  ->  COND . OR COND   (rule 55)
    WHILESTMT  ->  WHILE LEFTPAREN COND . RIGHTPAREN LEFTB STMTS RIGHTB   (rule 62)

    OR  	shift, and go to state 95
    AND 	shift, and go to state 96
    RIGHTPAREN	shift, and go to state 98



state 69

    VARDEF2  ->  INT . IDENTIFIER ASSIGN INT_CONST DOT   (rule 19)

    IDENTIFIER	shift, and go to state 99



state 70

    VARDEF2  ->  CHAR . IDENTIFIER ASSIGN CHAR_CONST DOT   (rule 20)

    IDENTIFIER	shift, and go to state 100



state 71

    FORSTMT  ->  FOR LEFTPAREN VARDEF2 . COND DOT STEP RIGHTPAREN LEFTB STMTS RIGHTB   (rule 63)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    NOT 	shift, and go to state 64
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    EXPR	go to state 65
    VALUE	go to state 52
    COND	go to state 101
    CONDS	go to state 67



state 72

    FUNCCALL  ->  IDENTIFIER LEFTPAREN . EXPR RIGHTPAREN   (rule 9)
    FUNCCALL  ->  IDENTIFIER LEFTPAREN . EXPR COMMA EXPR RIGHTPAREN   (rule 10)
    FUNCCALL  ->  IDENTIFIER LEFTPAREN . EXPR COMMA EXPR COMMA EXPR RIGHTPAREN   (rule 11)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    EXPR	go to state 102
    VALUE	go to state 52



state 73

    VALUE  ->  LEFTPAREN VALUE . RIGHTPAREN   (rule 49)

    RIGHTPAREN	shift, and go to state 103



state 74

    STMT  ->  RETURN EXPR DOT .   (rule 27)

    $default	reduce using rule 27 (STMT)



state 75

    EXPR  ->  VALUE ORBIT . VALUE   (rule 36)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    VALUE	go to state 104



state 76

    EXPR  ->  VALUE ANDBIT . VALUE   (rule 35)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    VALUE	go to state 105



state 77

    EXPR  ->  VALUE XORBIT . VALUE   (rule 37)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    VALUE	go to state 106



state 78

    EXPR  ->  VALUE PLUS . VALUE   (rule 31)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    VALUE	go to state 107



state 79

    EXPR  ->  VALUE MINUS . VALUE   (rule 32)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    VALUE	go to state 108



state 80

    EXPR  ->  VALUE MULTIPLY . VALUE   (rule 33)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    VALUE	go to state 109



state 81

    EXPR  ->  VALUE DIVIDE . VALUE   (rule 34)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    VALUE	go to state 110



state 82

    STEP  ->  IDENTIFIER ASSIGN EXPR .   (rule 30)

    $default	reduce using rule 30 (STEP)



state 83

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER . RIGHTPAREN LEFTB STMTS RIGHTB   (rule 7)
    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER . COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 8)

    COMMA	shift, and go to state 111
    RIGHTPAREN	shift, and go to state 112



state 84

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS . RIGHTB   (rule 6)

    RIGHTB	shift, and go to state 113



state 85

    VARDEF2  ->  INT IDENTIFIER ASSIGN INT_CONST . DOT   (rule 19)

    DOT 	shift, and go to state 114



state 86

    VARDEF2  ->  CHAR IDENTIFIER ASSIGN CHAR_CONST . DOT   (rule 20)

    DOT 	shift, and go to state 115



state 87

    COND  ->  NOT LEFTPAREN . COND RIGHTPAREN   (rule 52)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    NOT 	shift, and go to state 64
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    EXPR	go to state 65
    VALUE	go to state 52
    COND	go to state 116
    CONDS	go to state 67



state 88

    COMPOP  ->  ISLESSEQ .   (rule 41)

    $default	reduce using rule 41 (COMPOP)



state 89

    COMPOP  ->  ISMOREQ .   (rule 42)

    $default	reduce using rule 42 (COMPOP)



state 90

    COMPOP  ->  ISEQL .   (rule 43)

    $default	reduce using rule 43 (COMPOP)



state 91

    COMPOP  ->  ISNEQL .   (rule 44)

    $default	reduce using rule 44 (COMPOP)



state 92

    COMPOP  ->  LEFTB .   (rule 39)

    $default	reduce using rule 39 (COMPOP)



state 93

    COMPOP  ->  RIGHTB .   (rule 40)

    $default	reduce using rule 40 (COMPOP)



state 94

    COND  ->  EXPR COMPOP . EXPR   (rule 50)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    EXPR	go to state 117
    VALUE	go to state 52



state 95

    CONDS  ->  COND OR . COND   (rule 55)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    NOT 	shift, and go to state 64
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    EXPR	go to state 65
    VALUE	go to state 52
    COND	go to state 118
    CONDS	go to state 67



state 96

    CONDS  ->  COND AND . COND   (rule 54)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    NOT 	shift, and go to state 64
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    EXPR	go to state 65
    VALUE	go to state 52
    COND	go to state 119
    CONDS	go to state 67



state 97

    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN . LEFTB STMTS RIGHTB   (rule 56)
    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN . LEFTB STMTS RIGHTB ELSE LEFTB STMTS RIGHTB   (rule 57)
    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN . LEFTB STMTS RIGHTB ELIFSTMTS ELSE LEFTB STMTS RIGHTB   (rule 58)

    LEFTB	shift, and go to state 120



state 98

    WHILESTMT  ->  WHILE LEFTPAREN COND RIGHTPAREN . LEFTB STMTS RIGHTB   (rule 62)

    LEFTB	shift, and go to state 121



state 99

    VARDEF2  ->  INT IDENTIFIER . ASSIGN INT_CONST DOT   (rule 19)

    ASSIGN	shift, and go to state 61



state 100

    VARDEF2  ->  CHAR IDENTIFIER . ASSIGN CHAR_CONST DOT   (rule 20)

    ASSIGN	shift, and go to state 63



state 101

    CONDS  ->  COND . AND COND   (rule 54)
    CONDS  ->  COND . OR COND   (rule 55)
    FORSTMT  ->  FOR LEFTPAREN VARDEF2 COND . DOT STEP RIGHTPAREN LEFTB STMTS RIGHTB   (rule 63)

    DOT 	shift, and go to state 122
    OR  	shift, and go to state 95
    AND 	shift, and go to state 96



state 102

    FUNCCALL  ->  IDENTIFIER LEFTPAREN EXPR . RIGHTPAREN   (rule 9)
    FUNCCALL  ->  IDENTIFIER LEFTPAREN EXPR . COMMA EXPR RIGHTPAREN   (rule 10)
    FUNCCALL  ->  IDENTIFIER LEFTPAREN EXPR . COMMA EXPR COMMA EXPR RIGHTPAREN   (rule 11)

    COMMA	shift, and go to state 123
    RIGHTPAREN	shift, and go to state 124



state 103

    VALUE  ->  LEFTPAREN VALUE RIGHTPAREN .   (rule 49)

    $default	reduce using rule 49 (VALUE)



state 104

    EXPR  ->  VALUE ORBIT VALUE .   (rule 36)

    $default	reduce using rule 36 (EXPR)



state 105

    EXPR  ->  VALUE ANDBIT VALUE .   (rule 35)

    $default	reduce using rule 35 (EXPR)



state 106

    EXPR  ->  VALUE XORBIT VALUE .   (rule 37)

    $default	reduce using rule 37 (EXPR)



state 107

    EXPR  ->  VALUE PLUS VALUE .   (rule 31)

    $default	reduce using rule 31 (EXPR)



state 108

    EXPR  ->  VALUE MINUS VALUE .   (rule 32)

    $default	reduce using rule 32 (EXPR)



state 109

    EXPR  ->  VALUE MULTIPLY VALUE .   (rule 33)

    $default	reduce using rule 33 (EXPR)



state 110

    EXPR  ->  VALUE DIVIDE VALUE .   (rule 34)

    $default	reduce using rule 34 (EXPR)



state 111

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER COMMA . TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 8)

    INT 	shift, and go to state 13
    CHAR	shift, and go to state 2
    VOID	shift, and go to state 3

    TYPE	go to state 125



state 112

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN . LEFTB STMTS RIGHTB   (rule 7)

    LEFTB	shift, and go to state 126



state 113

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB .   (rule 6)

    $default	reduce using rule 6 (FUNC)



state 114

    VARDEF2  ->  INT IDENTIFIER ASSIGN INT_CONST DOT .   (rule 19)

    $default	reduce using rule 19 (VARDEF2)



state 115

    VARDEF2  ->  CHAR IDENTIFIER ASSIGN CHAR_CONST DOT .   (rule 20)

    $default	reduce using rule 20 (VARDEF2)



state 116

    COND  ->  NOT LEFTPAREN COND . RIGHTPAREN   (rule 52)
    CONDS  ->  COND . AND COND   (rule 54)
    CONDS  ->  COND . OR COND   (rule 55)

    OR  	shift, and go to state 95
    AND 	shift, and go to state 96
    RIGHTPAREN	shift, and go to state 127



state 117

    COND  ->  EXPR COMPOP EXPR .   (rule 50)

    $default	reduce using rule 50 (COND)



state 118

    CONDS  ->  COND . AND COND   (rule 54)
    CONDS  ->  COND . OR COND   (rule 55)
    CONDS  ->  COND OR COND .   (rule 55)


    $default	reduce using rule 55 (CONDS)



state 119

    CONDS  ->  COND . AND COND   (rule 54)
    CONDS  ->  COND AND COND .   (rule 54)
    CONDS  ->  COND . OR COND   (rule 55)


    $default	reduce using rule 54 (CONDS)



state 120

    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN LEFTB . STMTS RIGHTB   (rule 56)
    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN LEFTB . STMTS RIGHTB ELSE LEFTB STMTS RIGHTB   (rule 57)
    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN LEFTB . STMTS RIGHTB ELIFSTMTS ELSE LEFTB STMTS RIGHTB   (rule 58)

    INT 	shift, and go to state 19
    CHAR	shift, and go to state 20
    IF  	shift, and go to state 21
    WHILE	shift, and go to state 22
    CONTINUE	shift, and go to state 23
    BREAK	shift, and go to state 24
    FOR 	shift, and go to state 25
    RETURN	shift, and go to state 26
    IDENTIFIER	shift, and go to state 27

    STMTS	go to state 128
    VARDEF1	go to state 29
    VARDEF2	go to state 30
    STMT	go to state 31
    STEP	go to state 32
    IFSTMT	go to state 33
    WHILESTMT	go to state 34
    FORSTMT	go to state 35



state 121

    WHILESTMT  ->  WHILE LEFTPAREN COND RIGHTPAREN LEFTB . STMTS RIGHTB   (rule 62)

    INT 	shift, and go to state 19
    CHAR	shift, and go to state 20
    IF  	shift, and go to state 21
    WHILE	shift, and go to state 22
    CONTINUE	shift, and go to state 23
    BREAK	shift, and go to state 24
    FOR 	shift, and go to state 25
    RETURN	shift, and go to state 26
    IDENTIFIER	shift, and go to state 27

    STMTS	go to state 129
    VARDEF1	go to state 29
    VARDEF2	go to state 30
    STMT	go to state 31
    STEP	go to state 32
    IFSTMT	go to state 33
    WHILESTMT	go to state 34
    FORSTMT	go to state 35



state 122

    FORSTMT  ->  FOR LEFTPAREN VARDEF2 COND DOT . STEP RIGHTPAREN LEFTB STMTS RIGHTB   (rule 63)

    IDENTIFIER	shift, and go to state 27

    STEP	go to state 130



state 123

    FUNCCALL  ->  IDENTIFIER LEFTPAREN EXPR COMMA . EXPR RIGHTPAREN   (rule 10)
    FUNCCALL  ->  IDENTIFIER LEFTPAREN EXPR COMMA . EXPR COMMA EXPR RIGHTPAREN   (rule 11)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    EXPR	go to state 131
    VALUE	go to state 52



state 124

    FUNCCALL  ->  IDENTIFIER LEFTPAREN EXPR RIGHTPAREN .   (rule 9)

    $default	reduce using rule 9 (FUNCCALL)



state 125

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER COMMA TYPE . IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB   (rule 8)

    IDENTIFIER	shift, and go to state 132



state 126

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB . STMTS RIGHTB   (rule 7)

    INT 	shift, and go to state 19
    CHAR	shift, and go to state 20
    IF  	shift, and go to state 21
    WHILE	shift, and go to state 22
    CONTINUE	shift, and go to state 23
    BREAK	shift, and go to state 24
    FOR 	shift, and go to state 25
    RETURN	shift, and go to state 26
    IDENTIFIER	shift, and go to state 27

    STMTS	go to state 133
    VARDEF1	go to state 29
    VARDEF2	go to state 30
    STMT	go to state 31
    STEP	go to state 32
    IFSTMT	go to state 33
    WHILESTMT	go to state 34
    FORSTMT	go to state 35



state 127

    COND  ->  NOT LEFTPAREN COND RIGHTPAREN .   (rule 52)

    $default	reduce using rule 52 (COND)



state 128

    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN LEFTB STMTS . RIGHTB   (rule 56)
    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN LEFTB STMTS . RIGHTB ELSE LEFTB STMTS RIGHTB   (rule 57)
    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN LEFTB STMTS . RIGHTB ELIFSTMTS ELSE LEFTB STMTS RIGHTB   (rule 58)

    RIGHTB	shift, and go to state 134



state 129

    WHILESTMT  ->  WHILE LEFTPAREN COND RIGHTPAREN LEFTB STMTS . RIGHTB   (rule 62)

    RIGHTB	shift, and go to state 135



state 130

    FORSTMT  ->  FOR LEFTPAREN VARDEF2 COND DOT STEP . RIGHTPAREN LEFTB STMTS RIGHTB   (rule 63)

    RIGHTPAREN	shift, and go to state 136



state 131

    FUNCCALL  ->  IDENTIFIER LEFTPAREN EXPR COMMA EXPR . RIGHTPAREN   (rule 10)
    FUNCCALL  ->  IDENTIFIER LEFTPAREN EXPR COMMA EXPR . COMMA EXPR RIGHTPAREN   (rule 11)

    COMMA	shift, and go to state 137
    RIGHTPAREN	shift, and go to state 138



state 132

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER COMMA TYPE IDENTIFIER . RIGHTPAREN LEFTB STMTS RIGHTB   (rule 8)

    RIGHTPAREN	shift, and go to state 139



state 133

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS . RIGHTB   (rule 7)

    RIGHTB	shift, and go to state 140



state 134

    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB .   (rule 56)
    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB . ELSE LEFTB STMTS RIGHTB   (rule 57)
    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB . ELIFSTMTS ELSE LEFTB STMTS RIGHTB   (rule 58)

    ELSE	shift, and go to state 141
    ELSEIF	shift, and go to state 142

    $default	reduce using rule 56 (IFSTMT)

    ELIFSTMTS	go to state 143
    ELIFSTMT	go to state 144



state 135

    WHILESTMT  ->  WHILE LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB .   (rule 62)

    $default	reduce using rule 62 (WHILESTMT)



state 136

    FORSTMT  ->  FOR LEFTPAREN VARDEF2 COND DOT STEP RIGHTPAREN . LEFTB STMTS RIGHTB   (rule 63)

    LEFTB	shift, and go to state 145



state 137

    FUNCCALL  ->  IDENTIFIER LEFTPAREN EXPR COMMA EXPR COMMA . EXPR RIGHTPAREN   (rule 11)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    EXPR	go to state 146
    VALUE	go to state 52



state 138

    FUNCCALL  ->  IDENTIFIER LEFTPAREN EXPR COMMA EXPR RIGHTPAREN .   (rule 10)

    $default	reduce using rule 10 (FUNCCALL)



state 139

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN . LEFTB STMTS RIGHTB   (rule 8)

    LEFTB	shift, and go to state 147



state 140

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB .   (rule 7)

    $default	reduce using rule 7 (FUNC)



state 141

    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB ELSE . LEFTB STMTS RIGHTB   (rule 57)

    LEFTB	shift, and go to state 148



state 142

    ELIFSTMT  ->  ELSEIF . LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB   (rule 61)

    LEFTPAREN	shift, and go to state 149



state 143

    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB ELIFSTMTS . ELSE LEFTB STMTS RIGHTB   (rule 58)

    ELSE	shift, and go to state 150



state 144

    ELIFSTMTS  ->  ELIFSTMT . ELIFSTMTS   (rule 59)
    ELIFSTMTS  ->  ELIFSTMT .   (rule 60)

    ELSEIF	shift, and go to state 142

    $default	reduce using rule 60 (ELIFSTMTS)

    ELIFSTMTS	go to state 151
    ELIFSTMT	go to state 144



state 145

    FORSTMT  ->  FOR LEFTPAREN VARDEF2 COND DOT STEP RIGHTPAREN LEFTB . STMTS RIGHTB   (rule 63)

    INT 	shift, and go to state 19
    CHAR	shift, and go to state 20
    IF  	shift, and go to state 21
    WHILE	shift, and go to state 22
    CONTINUE	shift, and go to state 23
    BREAK	shift, and go to state 24
    FOR 	shift, and go to state 25
    RETURN	shift, and go to state 26
    IDENTIFIER	shift, and go to state 27

    STMTS	go to state 152
    VARDEF1	go to state 29
    VARDEF2	go to state 30
    STMT	go to state 31
    STEP	go to state 32
    IFSTMT	go to state 33
    WHILESTMT	go to state 34
    FORSTMT	go to state 35



state 146

    FUNCCALL  ->  IDENTIFIER LEFTPAREN EXPR COMMA EXPR COMMA EXPR . RIGHTPAREN   (rule 11)

    RIGHTPAREN	shift, and go to state 153



state 147

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB . STMTS RIGHTB   (rule 8)

    INT 	shift, and go to state 19
    CHAR	shift, and go to state 20
    IF  	shift, and go to state 21
    WHILE	shift, and go to state 22
    CONTINUE	shift, and go to state 23
    BREAK	shift, and go to state 24
    FOR 	shift, and go to state 25
    RETURN	shift, and go to state 26
    IDENTIFIER	shift, and go to state 27

    STMTS	go to state 154
    VARDEF1	go to state 29
    VARDEF2	go to state 30
    STMT	go to state 31
    STEP	go to state 32
    IFSTMT	go to state 33
    WHILESTMT	go to state 34
    FORSTMT	go to state 35



state 148

    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB ELSE LEFTB . STMTS RIGHTB   (rule 57)

    INT 	shift, and go to state 19
    CHAR	shift, and go to state 20
    IF  	shift, and go to state 21
    WHILE	shift, and go to state 22
    CONTINUE	shift, and go to state 23
    BREAK	shift, and go to state 24
    FOR 	shift, and go to state 25
    RETURN	shift, and go to state 26
    IDENTIFIER	shift, and go to state 27

    STMTS	go to state 155
    VARDEF1	go to state 29
    VARDEF2	go to state 30
    STMT	go to state 31
    STEP	go to state 32
    IFSTMT	go to state 33
    WHILESTMT	go to state 34
    FORSTMT	go to state 35



state 149

    ELIFSTMT  ->  ELSEIF LEFTPAREN . COND RIGHTPAREN LEFTB STMTS RIGHTB   (rule 61)

    IDENTIFIER	shift, and go to state 46
    INT_CONST	shift, and go to state 47
    CHAR_CONST	shift, and go to state 48
    NOT 	shift, and go to state 64
    LEFTPAREN	shift, and go to state 49

    FUNCCALL	go to state 50
    EXPR	go to state 65
    VALUE	go to state 52
    COND	go to state 156
    CONDS	go to state 67



state 150

    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB ELIFSTMTS ELSE . LEFTB STMTS RIGHTB   (rule 58)

    LEFTB	shift, and go to state 157



state 151

    ELIFSTMTS  ->  ELIFSTMT ELIFSTMTS .   (rule 59)

    $default	reduce using rule 59 (ELIFSTMTS)



state 152

    FORSTMT  ->  FOR LEFTPAREN VARDEF2 COND DOT STEP RIGHTPAREN LEFTB STMTS . RIGHTB   (rule 63)

    RIGHTB	shift, and go to state 158



state 153

    FUNCCALL  ->  IDENTIFIER LEFTPAREN EXPR COMMA EXPR COMMA EXPR RIGHTPAREN .   (rule 11)

    $default	reduce using rule 11 (FUNCCALL)



state 154

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS . RIGHTB   (rule 8)

    RIGHTB	shift, and go to state 159



state 155

    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB ELSE LEFTB STMTS . RIGHTB   (rule 57)

    RIGHTB	shift, and go to state 160



state 156

    CONDS  ->  COND . AND COND   (rule 54)
    CONDS  ->  COND . OR COND   (rule 55)
    ELIFSTMT  ->  ELSEIF LEFTPAREN COND . RIGHTPAREN LEFTB STMTS RIGHTB   (rule 61)

    OR  	shift, and go to state 95
    AND 	shift, and go to state 96
    RIGHTPAREN	shift, and go to state 161



state 157

    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB ELIFSTMTS ELSE LEFTB . STMTS RIGHTB   (rule 58)

    INT 	shift, and go to state 19
    CHAR	shift, and go to state 20
    IF  	shift, and go to state 21
    WHILE	shift, and go to state 22
    CONTINUE	shift, and go to state 23
    BREAK	shift, and go to state 24
    FOR 	shift, and go to state 25
    RETURN	shift, and go to state 26
    IDENTIFIER	shift, and go to state 27

    STMTS	go to state 162
    VARDEF1	go to state 29
    VARDEF2	go to state 30
    STMT	go to state 31
    STEP	go to state 32
    IFSTMT	go to state 33
    WHILESTMT	go to state 34
    FORSTMT	go to state 35



state 158

    FORSTMT  ->  FOR LEFTPAREN VARDEF2 COND DOT STEP RIGHTPAREN LEFTB STMTS RIGHTB .   (rule 63)

    $default	reduce using rule 63 (FORSTMT)



state 159

    FUNC  ->  TYPE IDENTIFIER LEFTPAREN TYPE IDENTIFIER COMMA TYPE IDENTIFIER COMMA TYPE IDENTIFIER RIGHTPAREN LEFTB STMTS RIGHTB .   (rule 8)

    $default	reduce using rule 8 (FUNC)



state 160

    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB ELSE LEFTB STMTS RIGHTB .   (rule 57)

    $default	reduce using rule 57 (IFSTMT)



state 161

    ELIFSTMT  ->  ELSEIF LEFTPAREN COND RIGHTPAREN . LEFTB STMTS RIGHTB   (rule 61)

    LEFTB	shift, and go to state 163



state 162

    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB ELIFSTMTS ELSE LEFTB STMTS . RIGHTB   (rule 58)

    RIGHTB	shift, and go to state 164



state 163

    ELIFSTMT  ->  ELSEIF LEFTPAREN COND RIGHTPAREN LEFTB . STMTS RIGHTB   (rule 61)

    INT 	shift, and go to state 19
    CHAR	shift, and go to state 20
    IF  	shift, and go to state 21
    WHILE	shift, and go to state 22
    CONTINUE	shift, and go to state 23
    BREAK	shift, and go to state 24
    FOR 	shift, and go to state 25
    RETURN	shift, and go to state 26
    IDENTIFIER	shift, and go to state 27

    STMTS	go to state 165
    VARDEF1	go to state 29
    VARDEF2	go to state 30
    STMT	go to state 31
    STEP	go to state 32
    IFSTMT	go to state 33
    WHILESTMT	go to state 34
    FORSTMT	go to state 35



state 164

    IFSTMT  ->  IF LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB ELIFSTMTS ELSE LEFTB STMTS RIGHTB .   (rule 58)

    $default	reduce using rule 58 (IFSTMT)



state 165

    ELIFSTMT  ->  ELSEIF LEFTPAREN COND RIGHTPAREN LEFTB STMTS . RIGHTB   (rule 61)

    RIGHTB	shift, and go to state 166



state 166

    ELIFSTMT  ->  ELSEIF LEFTPAREN COND RIGHTPAREN LEFTB STMTS RIGHTB .   (rule 61)

    $default	reduce using rule 61 (ELIFSTMT)



state 167

    $   	go to state 168



state 168

    $   	go to state 169



state 169

    $default	accept
